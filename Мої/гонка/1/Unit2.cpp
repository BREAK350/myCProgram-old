//---------------------------------------------------------------------------
#pragma hdrstop
#include "Unit2.h"
//---------------------------------------------------------------------------
p2d p2d::initxy(float _x,float _y)
{
    p2d p;
    x=p.x=_x;
    y=p.y=_y;
    return p;
}
//---------------------------------------------------------------------------
p2d p2d::initdalpha(float _d,float _alpha)
{
    p2d p;
    y=p.y=_d*sin(_alpha*M_PI/180);
    x=p.x=_d*cos(_alpha*M_PI/180);
    return p;
}
//---------------------------------------------------------------------------
float p2d::distance00()
{
    return sqrt(x*x+y*y);
}
//---------------------------------------------------------------------------
float p2d::angle()
{
    return ((x>=0)?((x==0)?(90):(atan(y/x)*180/M_PI)):(atan(y/x)*180/M_PI+180));
}
//---------------------------------------------------------------------------
p2d p2d::operator + (p2d _p)
{
    p2d p;
    p.x=x+_p.x;
    p.y=y+_p.y;
    return p;
}
//---------------------------------------------------------------------------
p2d p2d::operator - (p2d _p)
{
    p2d p;
    p.x=x-_p.x;
    p.y=y-_p.y;
    return p;
}
//---------------------------------------------------------------------------
v2d v2d::init(p2d _p1,p2d _p2)
{
    v2d v;
    p=v.p=_p1;
    d=v.d=(_p2-_p1).distance00();
    alpha=v.alpha=(_p2-_p1).angle();
    return v;
}
//---------------------------------------------------------------------------
v2d v2d::init(p2d _p,float _d,float _alpha)
{
    v2d v;
    p=v.p=_p;
    d=v.d=_d;
    alpha=v.alpha=_alpha;
    return v;
}
//---------------------------------------------------------------------------
v2d v2d::init(float _x,float _y,float _d,float _alpha)
{
    v2d v;
    v.p=p.initxy(_x,_y);
    d=v.d=_d;
    alpha=v.alpha=_alpha;
    return v;
}
//---------------------------------------------------------------------------
v2d v2d::infuture()
{
    v2d v;
    v.d=d;
    v.alpha=alpha;
    v.p=p+v.p.initdalpha(d,alpha);
    return v;
}
//---------------------------------------------------------------------------
void v2d::move()
{
    p=infuture().p;
}
//---------------------------------------------------------------------------
v2d v2d::operator + (v2d _v)
{
    v2d v;
    v.p=p+_v.p;
    v.alpha=(infuture().p+_v.infuture().p).angle();
    v.d=(infuture().p+_v.infuture().p).distance00();
    //init(v.p,v.d,v.alpha);
    return v;
}
//---------------------------------------------------------------------------
v2d v2d::operator - (v2d _v)
{
    v2d v;
    v.p=p-_v.p;
    v.alpha=(infuture().p-_v.infuture().p).angle();
    v.d=(infuture().p-_v.infuture().p).distance00();
    //init(v.p,v.d,v.alpha);
    return v;
}
//---------------------------------------------------------------------------
void dv2d::drawcanvas(TCanvas *canvas)
{
    canvas->Ellipse(p.x+center.x-2,center.y-p.y+2,p.x+center.x+2,center.y-p.y-2);
    canvas->MoveTo(p.x+center.x,center.y-p.y);
    canvas->LineTo(infuture().p.x+center.x,center.y-infuture().p.y);
}
//---------------------------------------------------------------------------
l2d l2d::init(p2d _p1,p2d _p2)
{
    l2d l;
    l1=l.l1=_p1;
    l2=l.l2=_p2;
    return l;
}
//---------------------------------------------------------------------------
l2d l2d::init(float _x1,float _y1,float _x2,float _y2)
{
    l2d l;
    l1=l.l1.initxy(_x1,_y1);
    l2=l.l2.initxy(_x2,_y2);
    return l;
}
//---------------------------------------------------------------------------
void l2d::drawcanvas(TCanvas *canvas)
{
    canvas->MoveTo(l1.x+center.x,center.y-l1.y);
    canvas->LineTo(l2.x+center.x,center.y-l2.y);
}
//---------------------------------------------------------------------------
l2d* dv2d::rightmove(l2d*l,int n)
{
    int i;
    func f1,f2;
    f2=tofunc();
    for(i=0;i<n;i++)
    {
        f1=l[i].tofunc();
        if( f1.value(p)!=f1.value(infuture().p) && f2.value(l[i].l1)!=f2.value(l[i].l2) )
        {
            return &l[i];
        }
    }
    move();
    return NULL;
}
//---------------------------------------------------------------------------
func func::init(float _A,float _B,float _C)
{
    func f;
    A=f.A=_A;
    B=f.B=_B;
    C=f.C=_C;
    return f;
}
//---------------------------------------------------------------------------
float func::value(p2d _p)
{
    return (A*_p.x+B*_p.y+C>=0)?(1):(-1);
}
//---------------------------------------------------------------------------
func l2d::tofunc()
{
    func f;
    f.init(l2.y-l1.y,-l2.x+l1.x,l1.y*(l2.x-l1.x)-l1.x*(l2.y-l1.y));
    return f;
}
//---------------------------------------------------------------------------
func v2d::tofunc()
{
    func f;
    f.init(infuture().p.y-p.y,-infuture().p.x+p.x,p.y*(infuture().p.x-p.x)-p.x*(infuture().p.y-p.y));
    return f;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
#pragma package(smart_init)
 