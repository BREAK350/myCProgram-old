//---------------------------------------------------------------------------
#pragma hdrstop
#include "Unit3.h"
#pragma package(smart_init)
//---------------------------------------------------------------------------
T_Dictionary::T_Dictionary():W(0)
{
    N=0;
}
//---------------------------------------------------------------------------
T_Dictionary::T_Dictionary(const char *fname)
{
    if(LoadFromFile(fname)==0)
    {
        N=0;
        W=NULL;
    }
}
//---------------------------------------------------------------------------
T_Dictionary::~T_Dictionary()
{
    Delete();
    W=NULL;
    N=0;
}
//---------------------------------------------------------------------------
int T_Dictionary::SearchPathWord(const char *pw)const
{
    int row=0,pos=0;
    int Size=strlen(pw);
    while(row<N && pos!=-1 && pos!=Size)
    {
        pos=SearchPathWord(row,pw);
        row++;
    }
    if(row>=N)
    {
        pos=0;
    }
    return pos;
}
//---------------------------------------------------------------------------
int T_Dictionary::SearchPathWord(const int &row,const char *pw)const // row >=0 && row <N
{
    int i=0;
    while(pw[i] && pw[i]==W[row][i])
    {
        i++;
    }
    if(W[row][i]==0 && pw[i]==0)
    {
        i=-1;
    }
    return i;
}
//---------------------------------------------------------------------------
char* T_Dictionary::operator [] (const int &n)
{
    char *r=NULL;
    if(n>=0 && n<N)
    {
        r=strdup(W[n]);
    }
    return r;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void T_Used::Delete(T_ListItem *&Item)
{
    if(Item)
    {
        Delete(Item->Next);
        delete Item;
        Item=NULL;
    }
}
//---------------------------------------------------------------------------
int T_Used::Add(const int &data)
{
    int q=0;
    T_ListItem *p=First;
    if(p==NULL)
    {
        First=new T_ListItem(data);
    }
    else
    {
        if(Search(data)==0)
        {
            while(p->Next)
            {
                p=p->Next;
            }
            p->Next=new T_ListItem(data);
        }
        else
        {
            q=1;
        }
    }
    return q;
}
//---------------------------------------------------------------------------
int T_Used::Search(const int &data)const
{
    int q=0;
    T_ListItem *p=First;
    while(p && p->Data!=data)
    {
        p=p->Next;
    }
    if(p)
    {
        q=1;
    }
    return q;
}
//---------------------------------------------------------------------------
T_Used::T_Used(const T_Used &u)
{
    if(u.First)
    {
        First=new T_ListItem(u.First->Data);
        T_ListItem *p=u.First->Next,*t=First;
        while(p)
        {
            t->Next=new T_ListItem(p->Data);
            p=p->Next;
            t=t->Next;
        }
    }
    else
    {
        First=NULL;
    }
}
//---------------------------------------------------------------------------
T_Dictionary::T_Dictionary(const T_Dictionary &d)
{
    N=d.N;
    if(N>0)
    {
        int i;
        W=new char*[N];
        for(i=0;i<N;i++)
        {
            W[i]=strdup(d.W[i]);
        }
    }
    else
    {
        W=NULL;
    }
}
//---------------------------------------------------------------------------
void T_Dictionary::Delete()
{
    int i;
    if(W)
    {
        for(i=0;i<N;i++)
        {
            delete W[i];
        }
    }
    delete W;
    Used.Delete();
}
//---------------------------------------------------------------------------
int T_Dictionary::LoadFromFile(const char *fname)
{
    int q=0;
    ifstream F(fname);
    if(F.is_open())
    {
        int n;
        F>>n;
        if(n>0)
        {
            q=1;
            Delete();
            N=n;
            const int max=32;
            int i=0;
            char buf[max];
            W=new char*[N];
            while(i<N)
            {
                F>>buf;
                W[i]=strdup(buf);
                i++;
            }
        }
        F.close();
    }
    return q;
}
//---------------------------------------------------------------------------
const char* T_Dictionary::GetRandomWord()
{
    char *r=NULL;
    if(W)
    {
        randomize();
        int i=random(N);
        Used.Add(i);
        r=W[i];
    }
    return r;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

